# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NTSOMZ_BBPCatalogDockWidget
                                 A QGIS plugin
 Access to BBP of RKS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Pankin A.V. @ NTSOMZ
        email                : pankin_av@ntsomz.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QDateTime
from qgis.PyQt.QtWidgets import (
    QWidget,
    QListWidgetItem, 
    QTableWidgetItem, 
    QMessageBox,
    QPushButton,
    QHBoxLayout
)
from qgis.core import (
    QgsVectorLayer,
    QgsRasterLayer,
    QgsProject
)
from datetime import datetime
from . import bbp_requests
from .bbp_requests import bbp_order, bbp_search
from .bbp_requests.iLayers.layered import create_layer
from .bbp_requests.bbp_objects import (
    Scene, 
    BrowseImage, 
    BoundingShape,
    Order, 
    Product, 
    TileService, 
    Point
)
from .params.setting import BBPSetting
from typing import Any, List
#from dataclasses import dataclass,field

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ntsomzBBP_dockwidget_order_based.ui'))

#@dataclass
class checkedDataStructure():

    isChecked:bool = False
    data: Any = None
    layer:QgsRasterLayer = None
    
    def __init__(self, isChecked:bool, data: Any, layer:QgsRasterLayer = None):
        self.isChecked - isChecked
        self.data = data
        self.layer = layer

class NTSOMZ_BBPCatalogDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        #QMessageBox.about(None, "NTSOMZ_BBPCatalogDockWidget", "__init__: "+str(parent))
        super(NTSOMZ_BBPCatalogDockWidget, self).__init__(parent)
        #QMessageBox.about(None, "NTSOMZ_BBPCatalogDockWidget", "__init__: "+str(parent))
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        #self.initForm()
        self.iface = None
        self.scene_layer = None  
        self.orders = list()
        self.scenes = list()
        self.ordered_scenes = dict()
        self.request_order = None
        self.setupUi(self)
        
    def setupUi(self,parent):
        super(NTSOMZ_BBPCatalogDockWidget, self).setupUi(parent)
        #self.setupOrdersTab()
        self.setupScenesTab()
    
    def setupScenesTab(self):
        """
        scenes columns:
            1. checkbox
            2. orderID
            3. products
            4. order
            5. available
        """
        key: str = BBPSetting().instance.key
        self.leIDKey.setText(key)
        self.tblScenes.setColumnCount(2)
        self.tblScenes.setHorizontalHeaderLabels(["Scene ID", "Product"])
            #["Selected", "Scene ID", "Product", "Order", "Available"])
  
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def loadOrders(self):
        ret = True
        if self.request_order is None:
            self.request_order = bbp_order.requestOrders()
            if self.request_order is None:
                QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Order request Failed")
                return False
        current_orders = None
        current_scenes = None
        current_orders = self.request_order.getOrders()
        print(current_orders)
        if current_orders is None:
            QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Request failed. Possible reasons:\n 1. Server is down.\n 2. API key is invalid.")
            self.scenes = None
            self.orders = None
            ret = False
        else:
            current_orders = [checkedDataStructure(False, i) for i in current_orders]
            current_scenes = [checkedDataStructure(False, j) for i in current_orders for j in i.data.getProducts() if not j.tile_service is None]
            print(current_scenes)
        def crosscheck(ListReference:List[checkedDataStructure], ListInQuestion:List[checkedDataStructure]):
            if ListReference is None:
                return ListInQuestion
            if ListInQuestion is None:
                return None
            for i in ListInQuestion:
                for j in ListReference:
                    if i.data == j.data:
                        i.isChecked = j.isChecked
            return ListInQuestion
        if ret:
            self.orders = crosscheck(self.orders, current_orders)
            self.scenes = crosscheck(self.scenes, current_scenes)
            self.updateTabWidget()
        return ret

    def updateSceneTable(self):
        """
        scenes columns:
            1. checkbox
            2. orderID
            3. products
        """
        self.tblScenes.clear()
        self.tblScenes.setHorizontalHeaderLabels(["Scene ID", "Product"])
        if self.scenes is None:
            return
        local_scenes = [i for i in self.scenes if i.data.tile_service]
        self.tblScenes.setRowCount(len(local_scenes))
        for index, scene in enumerate(local_scenes):
            isChecked: bool = scene.isChecked
            scene:bbp_order.Product = scene.data
            """
            chbx = QTableWidgetItem()
            btn = QPushButton()
            btn.setText("Add")
            lay = QHBoxLayout()
            lay.addWidget(btn)
            lay.setAlignment(Qt.AlignCenter)
            lay.setContentsMargins(0, 0, 0, 0)
            chbx.setLayout(lay)
            QWidget* pWidget = new QWidget();
            QPushButton* btn_edit = new QPushButton();
            btn_edit->setText("Edit");
            QHBoxLayout* pLayout = new QHBoxLayout(pWidget);
            pLayout->addWidget(btn_edit);
            pLayout->setAlignment(Qt::AlignCenter);
            pLayout->setContentsMargins(0, 0, 0, 0);
            pWidget->setLayout(pLayout);
            ui.table->setCellWidget(i, 3, pWidget);
            """
            self.tblScenes.setItem(index, 0, QTableWidgetItem(str(scene.id)))
            self.tblScenes.setItem(index, 1, QTableWidgetItem(str(scene.product)))

    def updateTabWidget(self):
        self.updateSceneTable()

    def on_registed_ID_click(self):
        key = self.leIDKey.text()
        prev_key = BBPSetting().instance.key
        BBPSetting().setAPIKey(key)
        ret = self.loadOrders()
        if not ret:
            BBPSetting().setAPIKey(prev_key)
            self.leIDKey.setText(prev_key)
        self.updateTabWidget()

    def on_tableScenes_item_change(self, item: QTableWidgetItem):
        r = item.row()
        c = item.column()
        itemData = None if r >= len(self.scenes) and r < 0 else self.scenes[r]
        if itemData is None:  
            return 
        if not itemData.layer is None:
            try:
                print(itemData.layer.id())
            except RuntimeError as rex:
                itemData.layer = None
        if itemData.layer is None:
            layer = self.createMapLayer(itemData.data)
            if not layer is None: 
                itemData.layer = layer
                self.scenes[r] = itemData
                proj = QgsProject.instance()
                proj.addMapLayer(layer)

    def removeMapLayer(self):
        if not self.scene_layer is None:
            proj = QgsProject.instance()
            try:
                lnk = proj.mapLayers().get(self.scene_layer.id())
                if not lnk is None:
                    proj.removeMapLayer(self.scene_layer.id())
            except RuntimeError as rex:
                pass
            self.scene_layer = None

    def createMapLayer(self,product):
        tile_service: TileService = None
        scene_found: Scene = None
        tile_service, scene_found = self.__get_datasource(product)
        datatype = "Preview" if tile_service is None else "Tiles"
        layer = create_layer(product, tile_service, scene_found)
        return layer

    def addMapLayer(self, product):
        tile_service: TileService = None
        scene_found: Scene = None
        tile_service, scene_found = self.__get_datasource(product)
        datatype = "Preview" if tile_service is None else "Tiles"
        self.removeMapLayer()
        if self.scene_layer is None:
            layer = create_layer(product, tile_service, scene_found)
            if not layer is None:
                self.scene_layer = layer
                proj = QgsProject.instance()
                proj.addMapLayer(self.scene_layer)

    def updateLayer(self):
        checked_Scene = None
        for i in self.scenes:
            if i.isChecked:
                checked_Scene = i.data
                break
        if checked_Scene is None:
            self.removeMapLayer()
        else:
            self.addMapLayer(checked_Scene)

    @staticmethod
    def __get_datasource(scene:Product)->(TileService, Scene):
        sceneInfo = bbp_search.search_scene(scene.id, scene.product)
        return (scene.tile_service, sceneInfo)

    def on_tabWidget_change(self, tabIndex:int):
        pass