# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NTSOMZ_BBPCatalogDockWidget
                                 A QGIS plugin
 Access to BBP of RKS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Pankin A.V. @ NTSOMZ
        email                : pankin_av@ntsomz.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QDateTime
from qgis.PyQt.QtWidgets import (
    QWidget,
    QListWidgetItem, 
    QTableWidgetItem, 
    QMessageBox,
    QPushButton,
    QHBoxLayout
)
from qgis.core import (
    QgsVectorLayer,
    QgsRasterLayer,
    QgsProject
)
from datetime import datetime
from . import bbp_requests
from .bbp_requests import bbp_order, bbp_search
from .bbp_requests.iLayers.layered import create_layer
from .bbp_requests.bbp_objects import (
    Scene, 
    BrowseImage, 
    BoundingShape,
    Order, 
    Product, 
    TileService, 
    Point
)
from .params.setting import BBPSetting
from typing import Any, List
#from dataclasses import dataclass,field

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ntsomzBBP_dockwidget_order_based.ui'))

#@dataclass
class checkedDataStructure():

    isChecked:bool = False
    data: Any = None
    layer:QgsRasterLayer = None
    
    def __init__(self, isChecked:bool, data: Any, layer:QgsRasterLayer = None):
        self.isChecked - isChecked
        self.data = data
        self.layer = layer

class NTSOMZ_BBPCatalogDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        #QMessageBox.about(None, "NTSOMZ_BBPCatalogDockWidget", "__init__: "+str(parent))
        super(NTSOMZ_BBPCatalogDockWidget, self).__init__(parent)
        #QMessageBox.about(None, "NTSOMZ_BBPCatalogDockWidget", "__init__: "+str(parent))
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        #self.initForm()
        self.iface = None
        self.scene_layer = None  
        self.orders = list()
        self.scenes = list()
        self.ordered_scenes = dict()
        self.request_order = None
        self.setupUi(self)
        
    def setupUi(self,parent):
        super(NTSOMZ_BBPCatalogDockWidget, self).setupUi(parent)
        #self.setupOrdersTab()
        self.setupScenesTab()
        
    # def setupOrdersTab(self):
    #     """
    #     orders columns:
    #         1. checkbox
    #         2. orderID
    #         3. products
    #         4. status
    #         5. button-reorder
    #     """
    #     self.tblOrders.setColumnCount(5)
    #     self.tblOrders.setHorizontalHeaderLabels(["Selected", "ID", "Name", "Products", "Status"])

    
    def setupScenesTab(self):
        """
        scenes columns:
            1. checkbox
            2. orderID
            3. products
            4. order
            5. available
        """
        key: str = BBPSetting().instance.key
        self.leIDKey.setText(key)
        self.tblScenes.setColumnCount(2)
        self.tblScenes.setHorizontalHeaderLabels(["Scene ID", "Product"])
            #["Selected", "Scene ID", "Product", "Order", "Available"])
  
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def loadOrders(self):
        ret = True
        if self.request_order is None:
            self.request_order = bbp_order.requestOrders()
            if self.request_order is None:
                QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Order request Failed")
                return False
        current_orders = None
        current_scenes = None
        current_orders = self.request_order.getOrders()
        print(current_orders)
        if current_orders is None:
            QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Request failed. Possible reasons:\n 1. Server is down.\n 2. API key is invalid.")
            self.scenes = None
            self.orders = None
            ret = False
        else:
            current_orders = [checkedDataStructure(False, i) for i in current_orders]
            current_scenes = [checkedDataStructure(False, j) for i in current_orders for j in i.data.getProducts() if not j.tile_service is None]
            print(current_scenes)
            #QMessageBox.about(self, "NTSOMZ_BBPCatalog", str(current_scenes))
        def crosscheck(ListReference:List[checkedDataStructure], ListInQuestion:List[checkedDataStructure]):
            if ListReference is None:
                return ListInQuestion
            if ListInQuestion is None:
                return None
            for i in ListInQuestion:
                for j in ListReference:
                    if i.data == j.data:
                        i.isChecked = j.isChecked
            return ListInQuestion
        if ret:
            self.orders = crosscheck(self.orders, current_orders)
            self.scenes = crosscheck(self.scenes, current_scenes)
            self.updateTabWidget()
        return ret

    # def updateOrderTable(self):
    #     """
    #     orders columns:
    #         1. checkbox
    #         2. orderID
    #         3. responsive_id
    #         4. products
    #         5. state
    #     """
    #     self.tblOrders.clear()
    #     self.tblOrders.setHorizontalHeaderLabels(["Selected", "ID", "Name", "Products", "Status"])
    #     if self.orders is None:
    #         return
    #     self.tblOrders.setRowCount(len(self.orders))
    #     for index, order in enumerate(self.orders):
    #         isChecked: bool = order.isChecked
    #         order:bbp_order.Order = order.data
    #         chbx = QTableWidgetItem()
    #         check_state = Qt.Checked if isChecked else Qt.Unchecked
    #         chbx.setCheckState(check_state)
    #         self.tblOrders.setItem(index, 0, chbx)
    #         self.tblOrders.setItem(index, 1, QTableWidgetItem(str(order.id)))
    #         self.tblOrders.setItem(index, 2, QTableWidgetItem(str(order.responsive_id)))
    #         products = order.getProducts()
    #         products = "\n".join([str(i) for i in products])
    #         self.tblOrders.setItem(index, 3, QTableWidgetItem(products))
    #         self.tblOrders.setItem(index, 4, QTableWidgetItem(order.state))

    def updateSceneTable(self):
        """
        scenes columns:
            1. checkbox
            2. orderID
            3. products
        """
        self.tblScenes.clear()
        self.tblScenes.setHorizontalHeaderLabels(["Scene ID", "Product"])
        #self.tblScenes.setHorizontalHeaderLabels(["Selected", "Scene ID", "Product", "Order", "Available"])
        if self.scenes is None:
            return
        local_scenes = [i for i in self.scenes if i.data.tile_service]
        self.tblScenes.setRowCount(len(local_scenes))
        for index, scene in enumerate(local_scenes):
            isChecked: bool = scene.isChecked
            scene:bbp_order.Product = scene.data
            """
            chbx = QTableWidgetItem()
            btn = QPushButton()
            btn.setText("Add")
            lay = QHBoxLayout()
            lay.addWidget(btn)
            lay.setAlignment(Qt.AlignCenter)
            lay.setContentsMargins(0, 0, 0, 0)
            chbx.setLayout(lay)
            QWidget* pWidget = new QWidget();
            QPushButton* btn_edit = new QPushButton();
            btn_edit->setText("Edit");
            QHBoxLayout* pLayout = new QHBoxLayout(pWidget);
            pLayout->addWidget(btn_edit);
            pLayout->setAlignment(Qt::AlignCenter);
            pLayout->setContentsMargins(0, 0, 0, 0);
            pWidget->setLayout(pLayout);
            ui.table->setCellWidget(i, 3, pWidget);
            """
            # check_state = Qt.Checked if isChecked else Qt.Unchecked
            # chbx.setCheckState(check_state)
            #self.tblScenes.setItem(index, 0, chbx)
            self.tblScenes.setItem(index, 0, QTableWidgetItem(str(scene.id)))
            self.tblScenes.setItem(index, 1, QTableWidgetItem(str(scene.product)))
            # self.tblScenes.setItem(index, 2, QTableWidgetItem(str("N/D" if scene.parent is None else scene.parent.id)))
            # self.tblScenes.setItem(index, 3, QTableWidgetItem("Preview" if scene.tile_service is None else "Tile Service"))

    def updateTabWidget(self):
        self.updateSceneTable()
        # self.updateOrderTable()

    def on_registed_ID_click(self):
        key = self.leIDKey.text()
        prev_key = BBPSetting().instance.key
        BBPSetting().setAPIKey(key)
        ret = self.loadOrders()
        if not ret:
            BBPSetting().setAPIKey(prev_key)
        self.updateTabWidget()

    def on_tableScenes_item_change(self, item: QTableWidgetItem):
        r = item.row()
        c = item.column()
        #QMessageBox.about(self, "NTSOMZ_BBPCatalog", "on_tableScenes_item_change\n"+":".join([str(r), str(c)]))
        itemData = None if r >= len(self.scenes) and r < 0 else self.scenes[r]
        if itemData is None:
            #QMessageBox.about(self, "NTSOMZ_BBPCatalog", "on_tableScenes_item_change\n"+"itemData is None")        
            return 
        if not itemData.layer is None:
            try:
                print(itemData.layer.id())
            except RuntimeError as rex:
                itemData.layer = None
        if itemData.layer is None:
            layer = self.createMapLayer(itemData.data)
            #QMessageBox.about(self, "NTSOMZ_BBPCatalog", "on_tableScenes_item_change\n"+str(layer)) 
            if not layer is None: 
                itemData.layer = layer
                self.scenes[r] = itemData
                proj = QgsProject.instance()
                proj.addMapLayer(layer)
        # if c == 0:
        #     checkstate = item.checkState()
        #     checkstate = True if checkstate == Qt.Checked else False
        #     last_state = self.scenes[r].isChecked if r < len(self.scenes) else None
            
        #     #QMessageBox.about(self, "NTSOMZ_BBPCatalog", "on_tableScenes_item_change: "+ str(r)+" : "+str(c))
        #     if last_state is None: return
        #     if checkstate and not last_state:
        #         for i in self.scenes:
        #             i.isChecked = False
        #         self.scenes[r].isChecked = True
        #         self.updateSceneTable()
        #         self.updateLayer()
        #     elif not checkstate and last_state:
        #         self.scenes[r].isChecked = False
        #         self.updateLayer()

    # def on_tableOrders_item_change(self, item: QTableWidgetItem):
    #     r = item.row()
    #     c = item.column()
    #     if c == 0:
    #         checkstate = item.checkState()
    #         checkstate = True if checkstate == Qt.Checked else False
    #         last_state = self.orders[r].isChecked if r < len(self.orders) else None
            
    #         #QMessageBox.about(self, "NTSOMZ_BBPCatalog", "on_tableOrders_item_change: "+ str(r)+" : "+str(c))
    #         if last_state is None: return
    #         if checkstate and not last_state:
    #             for i in self.orders:
    #                 i.isChecked = False
    #             self.orders[r].isChecked = True
    #             self.updateOrderTable()
    #         elif not checkstate and last_state:
    #             self.orders[r].isChecked = False

    def removeMapLayer(self):
        if not self.scene_layer is None:
            proj = QgsProject.instance()
            try:
                lnk = proj.mapLayers().get(self.scene_layer.id())
                if not lnk is None:
                    proj.removeMapLayer(self.scene_layer.id())
            except RuntimeError as rex:
                pass
                #QMessageBox.about(self, "removeMapLayer", "\n ".join([str(rex)]))
            self.scene_layer = None

    def createMapLayer(self,product):
        tile_service: TileService = None
        scene_found: Scene = None
        tile_service, scene_found = self.__get_datasource(product)
        datatype = "Preview" if tile_service is None else "Tiles"
        layer = create_layer(product, tile_service, scene_found)
        return layer

    def addMapLayer(self, product):
        tile_service: TileService = None
        scene_found: Scene = None
        tile_service, scene_found = self.__get_datasource(product)
        datatype = "Preview" if tile_service is None else "Tiles"
        self.removeMapLayer()
        if self.scene_layer is None:
            #QMessageBox.about(self, "Loading a layer", "\n ".join([str(datatype), str(tile_service), str(scene_found)]))
            layer = create_layer(product, tile_service, scene_found)
            if not layer is None:
                self.scene_layer = layer
                proj = QgsProject.instance()
                proj.addMapLayer(self.scene_layer)


    def updateLayer(self):
        checked_Scene = None
        for i in self.scenes:
            if i.isChecked:
                checked_Scene = i.data
                break
        if checked_Scene is None:
            self.removeMapLayer()
        else:
            self.addMapLayer(checked_Scene)

    @staticmethod
    def __get_datasource(scene:Product)->(TileService, Scene):
        sceneInfo = bbp_search.search_scene(scene.id, scene.product)
        return (scene.tile_service, sceneInfo)

    def on_tabWidget_change(self, tabIndex:int):
        pass