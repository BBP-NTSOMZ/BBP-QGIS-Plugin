# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NTSOMZ_BBPCatalogDockWidget
                                 A QGIS plugin
 Access to BBP of RKS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Pankin A.V. @ NTSOMZ
        email                : pankin_av@ntsomz.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.core import QgsRectangle, QgsCoordinateReferenceSystem, QgsCoordinateTransform
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QDateTime
from qgis.PyQt.QtWidgets import (
    QWidget,
    QListWidgetItem, 
    QTableWidgetItem, 
    QMessageBox,
    QPushButton,
    QHBoxLayout
)
from qgis.core import (
    QgsVectorLayer,
    QgsRasterLayer,
    QgsProject
)
from .bbp_requests import bsp_product
from datetime import datetime
from . import bbp_requests
from .bbp_requests import bbp_order, bbp_search
from .bbp_requests.iLayers.layered import create_layer
from .bbp_requests.bbp_objects import (
    Scene, 
    BrowseImage, 
    BoundingShape,
    Order, 
    Product, 
    TileService, 
    Point
)
from .params.setting import BBPSetting
from typing import Any, List
#from dataclasses import dataclass,field

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ntsomzBBP_dockwidget_order_based.ui'))

#@dataclass
class checkedDataStructure():

    isChecked: bool = False
    data: Any = None
    layer: QgsRasterLayer = None
    
    def __init__(self, isChecked: bool, data: Any, layer: QgsRasterLayer = None):
        self.isChecked - isChecked
        self.data = data
        self.layer = layer

class NTSOMZ_BBPCatalogDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        #QMessageBox.about(None, "NTSOMZ_BBPCatalogDockWidget", "__init__: "+str(parent))
        super(NTSOMZ_BBPCatalogDockWidget, self).__init__(parent)
        #QMessageBox.about(None, "NTSOMZ_BBPCatalogDockWidget", "__init__: "+str(parent))
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # # widgets-and-dialogs-with-auto-connect
        # self.initForm()
        self.iface = None
        self.scene_layer = None  
        self.orders = list()
        self.scenes = list()
        self.ordered_scenes = dict()
        self.request_order = None

        self.regMsg = False
        self.mosaicList = None
        self.bspApiKey = None

        self.setupUi(self)
        
    def setupUi(self, parent):
        super(NTSOMZ_BBPCatalogDockWidget, self).setupUi(parent)
        # self.setupOrdersTab()
        self.setupScenesTab()
        self.setupBspTab()
    
    def setupScenesTab(self):
        """
        scenes columns:
            1. checkbox
            2. orderID
            3. products
            4. order
            5. available
        """
        key: str = BBPSetting().instance.key
        self.leIDKey.setText(key)
        self.tblScenes.setColumnCount(2)
        self.tblScenes.setHorizontalHeaderLabels(["Scene ID", "Product"])
            #["Selected", "Scene ID", "Product", "Order", "Available"])

    def getLayersName(self):
        nameLayersList = []

        mapLayers = QgsProject.instance().mapLayers()
        for layer_uniqName, layerObj in mapLayers.items():
            nameLayersList.append(layerObj.name())

        return nameLayersList

    def createBspLayer(self, URL, fullName, max_zoom, min_zoom):
        rasterLayer = None
        layers = self.getLayersName()

        if not fullName in layers:
            rasterLayer = QgsRasterLayer("type=xyz&url=" + URL  # префикс URL + URL
                                         + '?api_key=' + self.bspApiKey  # префикс ключа + ключ
                                         + '&zmax={zmax}&zmin={zmin}'.format(zmax=max_zoom,zmin=min_zoom), # min-max zoom
                                         fullName, "wms")
            QgsProject.instance().addMapLayer(rasterLayer)

        return rasterLayer


    def addAllBspLayers(self):
        objectsList = self.mosaicList
        if objectsList is None:
            QMessageBox.about(self, "NTSOMZ_BBPCatalog", "List of mosaics is empty")
            return

        for object in objectsList:
            fullName = object.mosaic_id + ':' + object.tile_services.productType + ':' + object.tile_services.color_representation
            self.createBspLayer(object.tile_services.color_representation, fullName, object.tile_services.max_zoom, object.tile_services.min_zoom)

            if not object.tile_services.additional_colors.colors is None:
                for additColor, additColorUrl in object.tile_services.additional_colors.colors.items():
                    fullName = object.mosaic_id + ':' + object.tile_services.productType + ':' + additColor
                    self.createBspLayer(additColorUrl, fullName, object.tile_services.max_zoom, object.tile_services.min_zoom)

    def addBspLayer(self, selectedRow, selectedColumn):
        # columns 1 and 2
        if selectedColumn in range(2):
            local_mosaic_id = self.tblBsp.item(selectedRow, 0).text()
            local_productType = self.tblBsp.item(selectedRow, 1).text()
            local_color_representation = self.tblBsp.cellWidget(selectedRow, 2).currentText()

            fullName = local_mosaic_id+':'+local_productType+':'+local_color_representation

            objectsList = self.mosaicList
            if objectsList is None:
                return

            for object in objectsList:
                if object.mosaic_id == local_mosaic_id:
                    if object.tile_services.productType == local_productType:
                        URL = None

                        if local_color_representation in object.tile_services.color_representation:
                            URL = object.tile_services.main_url
                        elif local_color_representation in object.tile_services.additional_colors.colors.keys():
                            URL = object.tile_services.additional_colors.colors[local_color_representation]

                        if not URL is None:
                            rasterLayer = self.createBspLayer(URL, fullName, object.tile_services.max_zoom, object.tile_services.min_zoom)
                            if not rasterLayer is None:
                                boundingbox = object.tile_services.bbox
                                crsSrc = QgsCoordinateReferenceSystem("EPSG:4326")  # WGS 84
                                crsDest = QgsCoordinateReferenceSystem("EPSG:3857")  # Preudo-mercator
                                transformContext = QgsProject.instance().transformContext()
                                xform = QgsCoordinateTransform(crsSrc, crsDest, transformContext)
                                boundingbox = [*xform.transform(boundingbox[0], boundingbox[1]), *xform.transform(boundingbox[2], boundingbox[3])]

                                extentRect = QgsRectangle(*boundingbox)
                                rasterLayer.setExtent(extentRect)

                                canvas = self.iface.mapCanvas()
                                canvas.setExtent(rasterLayer.extent())

    def updateBspTable(self):
        self.tblBsp.clear()
        self.tblBsp.setRowCount(0)

        self.tblBsp.setHorizontalHeaderLabels(["Mosaic ID", "Product type", "Color representation"])

        objectsList = self.mosaicList
        if objectsList is None:
            return

        self.tblBsp.setRowCount(len(objectsList))
        for index, object in enumerate(objectsList):
            self.tblBsp.setItem(index, 0, QTableWidgetItem(object.mosaic_id))
            self.tblBsp.setItem(index, 1, QTableWidgetItem(object.tile_services.productType))

            colorBox = QtWidgets.QComboBox()
            colorBox.addItem(object.tile_services.color_representation)
            self.tblBsp.setCellWidget(index, 2, colorBox)

            if not object.tile_services.additional_colors.colors is None:
                for additColor, additColorUrl in object.tile_services.additional_colors.colors.items():
                    colorBox.addItem(additColor)

        self.tblBsp.resizeColumnsToContents()

    def setupBspTab(self):
        self.tblBsp.setColumnCount(3)
        self.tblBsp.setHorizontalHeaderLabels(["Mosaic ID", "Product type", "Color representation"])

    def getBSP(self):
        ret = True
        self.mosaicList = bsp_product.sendBspRequest(self.bspApiKey)

        if self.mosaicList is None:
            # QMessageBox.about(self, "NTSOMZ_BBPCatalog", "BSP request failed. Possible reasons:\n1. Server is down.\n2. API key is invalid.")
            ret = False

        return ret

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def loadOrders(self):
        ret = True
        if self.request_order is None:
            self.request_order = bbp_order.requestOrders()
            if self.request_order is None:
                # QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Orders request Failed")
                return False
        current_orders = None
        current_scenes = None
        current_orders = self.request_order.getOrders()
        print(current_orders)
        if current_orders is None:
            # QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Orders request failed. Possible reasons:\n1. Server is down.\n2. API key is invalid.")
            self.scenes = None
            self.orders = None
            ret = False
        else:
            current_orders = [checkedDataStructure(False, i) for i in current_orders]
            current_scenes = [checkedDataStructure(False, j) for i in current_orders for j in i.data.getProducts() if not j.tile_service is None]
            print(current_scenes)
        def crosscheck(ListReference:List[checkedDataStructure], ListInQuestion:List[checkedDataStructure]):
            if ListReference is None:
                return ListInQuestion
            if ListInQuestion is None:
                return None
            for i in ListInQuestion:
                for j in ListReference:
                    if i.data == j.data:
                        i.isChecked = j.isChecked
            return ListInQuestion

        if ret:
            self.orders = crosscheck(self.orders, current_orders)
            self.scenes = crosscheck(self.scenes, current_scenes)
            self.updateTabWidget()
        return ret

    def updateSceneTable(self):
        self.tblScenes.clear()
        self.tblScenes.setRowCount(0)

        self.tblScenes.setHorizontalHeaderLabels(["Scene ID", "Product"])
        if self.scenes is None:
            return
        local_scenes = [i for i in self.scenes if i.data.tile_service]
        self.tblScenes.setRowCount(len(local_scenes))
        for index, scene in enumerate(local_scenes):
            isChecked: bool = scene.isChecked
            scene: bbp_order.Product = scene.data
            """
            chbx = QTableWidgetItem()
            btn = QPushButton()
            btn.setText("Add")
            lay = QHBoxLayout()
            lay.addWidget(btn)
            lay.setAlignment(Qt.AlignCenter)
            lay.setContentsMargins(0, 0, 0, 0)
            chbx.setLayout(lay)
            QWidget* pWidget = new QWidget();
            QPushButton* btn_edit = new QPushButton();
            btn_edit->setText("Edit");
            QHBoxLayout* pLayout = new QHBoxLayout(pWidget);
            pLayout->addWidget(btn_edit);
            pLayout->setAlignment(Qt::AlignCenter);
            pLayout->setContentsMargins(0, 0, 0, 0);
            pWidget->setLayout(pLayout);
            ui.table->setCellWidget(i, 3, pWidget);
            """
            self.tblScenes.setItem(index, 0, QTableWidgetItem(str(scene.id)))
            self.tblScenes.setItem(index, 1, QTableWidgetItem(str(scene.product)))

    def updateTabWidget(self):
        self.updateSceneTable()

    def on_registed_ID_click(self):
        self.regMsg = False
        key = self.leIDKey.text()
        prev_key = BBPSetting().instance.key
        BBPSetting().setAPIKey(key)
        retScene = self.loadOrders()
        if not retScene:
            BBPSetting().setAPIKey(prev_key)
            self.leIDKey.setText(prev_key)
            self.regMsg = True
            QMessageBox.about(self, "NTSOMZ_BBPCatalog", "Key registration failed.\n\nPossible reasons:\n1. API key is invalid.\n2. Server is down.")
        self.updateTabWidget()

        # BSP part
        self.bspApiKey = key
        retBsp = self.getBSP()
        self.updateBspTable()

        try:
            len_scenes = len(self.scenes)
        except TypeError:
            if self.scenes is None:
                len_scenes = 0

        if not self.regMsg:
            scenesMsg = ''
            bspMsg = ''

            if len_scenes == 0:
                scenesMsg = "Can`t load scenes. Orders not found in BBP interactive catalog.\n"

            if not retBsp:
                bspMsg = "\nNo mosaics available for the specified API key.\n"

            QMessageBox.about(self, "NTSOMZ_BBPCatalog", scenesMsg+bspMsg)

    def on_tableScenes_item_change(self, item: QTableWidgetItem):
        r = item.row()
        c = item.column()
        itemData = None if r >= len(self.scenes) and r < 0 else self.scenes[r]
        if itemData is None:  
            return 
        if not itemData.layer is None:
            try:
                print(itemData.layer.id())
            except RuntimeError as rex:
                itemData.layer = None
        if itemData.layer is None:
            layer = self.createMapLayer(itemData.data)
            if not layer is None: 
                itemData.layer = layer
                self.scenes[r] = itemData
                proj = QgsProject.instance()
                proj.addMapLayer(layer)

    def removeMapLayer(self):
        if not self.scene_layer is None:
            proj = QgsProject.instance()
            try:
                lnk = proj.mapLayers().get(self.scene_layer.id())
                if not lnk is None:
                    proj.removeMapLayer(self.scene_layer.id())
            except RuntimeError as rex:
                pass
            self.scene_layer = None

    def createMapLayer(self,product):
        tile_service: TileService = None
        scene_found: Scene = None
        tile_service, scene_found = self.__get_datasource(product)
        datatype = "Preview" if tile_service is None else "Tiles"
        layer = create_layer(product, tile_service, scene_found)
        return layer

    def addMapLayer(self, product):
        tile_service: TileService = None
        scene_found: Scene = None
        tile_service, scene_found = self.__get_datasource(product)
        datatype = "Preview" if tile_service is None else "Tiles"
        self.removeMapLayer()
        if self.scene_layer is None:
            layer = create_layer(product, tile_service, scene_found)
            if not layer is None:
                self.scene_layer = layer
                proj = QgsProject.instance()
                proj.addMapLayer(self.scene_layer)

    def updateLayer(self):
        checked_Scene = None
        for i in self.scenes:
            if i.isChecked:
                checked_Scene = i.data
                break
        if checked_Scene is None:
            self.removeMapLayer()
        else:
            self.addMapLayer(checked_Scene)

    @staticmethod
    def __get_datasource(scene:Product)->(TileService, Scene):
        sceneInfo = bbp_search.search_scene(scene.id, scene.product)
        return (scene.tile_service, sceneInfo)

    def on_tabWidget_change(self, tabIndex:int):
        pass